<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>La balise HTML &lt;geolocation> arrive : ce que ça change pour les devs indie | LabVeilleTech - Ksel</title>
<meta name=keywords content="HTML,Géolocalisation,Web API,Chrome"><meta name=description content="Chrome 144 introduit un nouvel élément HTML : <geolocation>. Pour les indie hackers qui développent des apps web avec des fonctionnalités de localisation, c&rsquo;est une simplification bienvenue — et une occasion de réfléchir aux limites du web face au natif.
Ce que change la balise <geolocation>
Jusqu&rsquo;à maintenant, demander la position d&rsquo;un utilisateur passait par l&rsquo;API JavaScript navigator.geolocation.getCurrentPosition(). Le problème : cette approche impérative déclenche des popups d&rsquo;autorisation qui interrompent l&rsquo;utilisateur, souvent au mauvais moment. Pire, si l&rsquo;utilisateur refuse trois fois, Chrome bloque silencieusement les demandes pendant une semaine. Ton code échoue sans explication."><meta name=author content><link rel=canonical href=https://example.org/articles/article-geolocation-html/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://example.org/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://example.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://example.org/favicon-32x32.png><link rel=apple-touch-icon href=https://example.org/apple-touch-icon.png><link rel=mask-icon href=https://example.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://example.org/articles/article-geolocation-html/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://example.org/articles/article-geolocation-html/"><meta property="og:site_name" content="LabVeilleTech - Ksel"><meta property="og:title" content="La balise HTML arrive : ce que ça change pour les devs indie"><meta property="og:description" content="Chrome 144 introduit un nouvel élément HTML : <geolocation>. Pour les indie hackers qui développent des apps web avec des fonctionnalités de localisation, c’est une simplification bienvenue — et une occasion de réfléchir aux limites du web face au natif.
Ce que change la balise <geolocation> Jusqu’à maintenant, demander la position d’un utilisateur passait par l’API JavaScript navigator.geolocation.getCurrentPosition(). Le problème : cette approche impérative déclenche des popups d’autorisation qui interrompent l’utilisateur, souvent au mauvais moment. Pire, si l’utilisateur refuse trois fois, Chrome bloque silencieusement les demandes pendant une semaine. Ton code échoue sans explication."><meta property="og:locale" content="fr"><meta property="og:type" content="article"><meta property="article:section" content="articles"><meta property="article:published_time" content="2025-01-16T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-16T00:00:00+00:00"><meta property="article:tag" content="HTML"><meta property="article:tag" content="Géolocalisation"><meta property="article:tag" content="Web API"><meta property="article:tag" content="Chrome"><meta name=twitter:card content="summary"><meta name=twitter:title content="La balise HTML <geolocation> arrive : ce que ça change pour les devs indie"><meta name=twitter:description content="Chrome 144 introduit un nouvel élément HTML : <geolocation>. Pour les indie hackers qui développent des apps web avec des fonctionnalités de localisation, c&rsquo;est une simplification bienvenue — et une occasion de réfléchir aux limites du web face au natif.
Ce que change la balise <geolocation>
Jusqu&rsquo;à maintenant, demander la position d&rsquo;un utilisateur passait par l&rsquo;API JavaScript navigator.geolocation.getCurrentPosition(). Le problème : cette approche impérative déclenche des popups d&rsquo;autorisation qui interrompent l&rsquo;utilisateur, souvent au mauvais moment. Pire, si l&rsquo;utilisateur refuse trois fois, Chrome bloque silencieusement les demandes pendant une semaine. Ton code échoue sans explication."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Articles","item":"https://example.org/articles/"},{"@type":"ListItem","position":2,"name":"La balise HTML \u003cgeolocation\u003e arrive : ce que ça change pour les devs indie","item":"https://example.org/articles/article-geolocation-html/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"La balise HTML arrive : ce que ça change pour les devs indie","name":"La balise HTML arrive : ce que ça change pour les devs indie","description":"Chrome 144 introduit un nouvel élément HTML : \u0026lt;geolocation\u0026gt;. Pour les indie hackers qui développent des apps web avec des fonctionnalités de localisation, c\u0026rsquo;est une simplification bienvenue — et une occasion de réfléchir aux limites du web face au natif.\nCe que change la balise \u0026lt;geolocation\u0026gt; Jusqu\u0026rsquo;à maintenant, demander la position d\u0026rsquo;un utilisateur passait par l\u0026rsquo;API JavaScript navigator.geolocation.getCurrentPosition(). Le problème : cette approche impérative déclenche des popups d\u0026rsquo;autorisation qui interrompent l\u0026rsquo;utilisateur, souvent au mauvais moment. Pire, si l\u0026rsquo;utilisateur refuse trois fois, Chrome bloque silencieusement les demandes pendant une semaine. Ton code échoue sans explication.\n","keywords":["HTML","Géolocalisation","Web API","Chrome"],"articleBody":"Chrome 144 introduit un nouvel élément HTML : . Pour les indie hackers qui développent des apps web avec des fonctionnalités de localisation, c’est une simplification bienvenue — et une occasion de réfléchir aux limites du web face au natif.\nCe que change la balise Jusqu’à maintenant, demander la position d’un utilisateur passait par l’API JavaScript navigator.geolocation.getCurrentPosition(). Le problème : cette approche impérative déclenche des popups d’autorisation qui interrompent l’utilisateur, souvent au mauvais moment. Pire, si l’utilisateur refuse trois fois, Chrome bloque silencieusement les demandes pendant une semaine. Ton code échoue sans explication.\nLa nouvelle balise change la donne. L’autorisation est déclenchée uniquement quand l’utilisateur clique sur l’élément — pas au chargement de la page, pas via un script. C’est déclaratif, contextuel, et contrôlé par le navigateur.\n\u003cgeolocation onlocation=\"handleLocation(event)\" accuracymode=\"precise\"\u003e \u003c/geolocation\u003e function handleLocation(event) { if (event.target.position) { const { latitude, longitude } = event.target.position.coords; console.log(\"Position :\", latitude, longitude); } } Plus besoin de gérer manuellement les callbacks, les états d’erreur, les cas de blocage. Le navigateur s’occupe de tout, y compris d’un flux de récupération si l’utilisateur avait précédemment bloqué l’accès.\nLes chiffres qui valident le concept Avant de lancer la balise , Chrome a testé un élément générique pendant plusieurs versions. Les résultats sont parlants :\nZoom : -46,9% d’erreurs de capture caméra/micro Immobiliare.it : +20% de flux de géolocalisation réussis ZapImóveis : 54,4% de récupération pour les utilisateurs précédemment bloqués Le problème n’était pas la fonctionnalité. C’était le manque de contexte au moment de la demande.\nLe parallèle avec mon projet Track J’ai récemment terminé Track, une PWA de tracking sportif développée dans le cadre d’un projet croisé entre deux cours à la HEIG-VD (ArchiOWeb et DevMobil). L’app enregistre les sorties running/vélo via les capteurs du téléphone : tracé GPS en temps réel, calcul de distance et dénivelé, photos géolocalisées, enrichissement météo automatique.\nLa géolocalisation était au cœur du projet. Avec l’API JavaScript actuelle, j’ai dû gérer pas mal de cas limites : utilisateur qui refuse, blocage silencieux, demande qui arrive trop tôt dans le flow. La balise aurait simplifié cette partie du code.\nMais — et c’est là que ça devient intéressant — même avec cette amélioration, le web reste limité face au natif.\nLes limites du web : l’exemple de l’altimètre barométrique En développant Track, j’ai voulu intégrer l’altitude barométrique. Sur une app native, l’altimètre du téléphone donne une altitude précise et réactive, idéale pour calculer le dénivelé en temps réel.\nSur le web ? Impossible. L’API Geolocation donne une altitude GPS, mais elle est bruitée et peu fiable pour du tracking sportif précis. L’altimètre barométrique, lui, n’est tout simplement pas exposé aux applications web.\nC’est le genre de friction qui pousse certains projets vers le natif ou vers des solutions hybrides comme Capacitor. Pour un side project ou un MVP, ça peut être un deal-breaker.\nLa balise améliore l’expérience utilisateur, mais elle ne résout pas ce problème fondamental : certains capteurs restent hors de portée du web.\nPourquoi c’est pertinent pour les indie hackers Cette évolution s’adresse surtout aux indie hackers avec un background dev — ceux qui comprennent comment fonctionne l’API Geolocation actuelle et qui peuvent apprécier la simplification.\nConcrètement, si tu développes :\nUne app de livraison ou de services géolocalisés Un outil de tracking (sport, transport, logistique) Une fonctionnalité “trouver autour de moi” …cette balise va te faire gagner du temps et améliorer ton taux de conversion sur les autorisations.\nL’amélioration progressive est aussi bien pensée : tu peux utiliser la balise avec un fallback vers l’API JavaScript pour les navigateurs non compatibles.\n\u003cgeolocation onlocation=\"updateMap()\"\u003e \u003cbutton onclick=\"navigator.geolocation.getCurrentPosition(updateMap)\"\u003e Utiliser ma position \u003c/button\u003e \u003c/geolocation\u003e Quand cette info me sera utile Pour mes futurs projets demandant la géolocalisation, je garderai cette balise en tête. Elle simplifie le code, améliore l’UX, et réduit les frictions liées aux permissions.\nMais je resterai aussi conscient des limites du web. Pour certains cas d’usage sportifs ou IoT, le natif reste incontournable. La question à se poser avant de commencer : est-ce que les capteurs dont j’ai besoin sont accessibles depuis le navigateur ?\nSource : Chrome for Developers\n","wordCount":"691","inLanguage":"en","datePublished":"2025-01-16T00:00:00Z","dateModified":"2025-01-16T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://example.org/articles/article-geolocation-html/"},"publisher":{"@type":"Organization","name":"LabVeilleTech - Ksel","logo":{"@type":"ImageObject","url":"https://example.org/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://example.org/ accesskey=h title="LabVeilleTech - Ksel (Alt + H)">LabVeilleTech - Ksel</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://example.org/ title=Accueil><span>Accueil</span></a></li><li><a href=https://example.org/articles/ title=Articles><span>Articles</span></a></li><li><a href=https://example.org/about/ title="À propos"><span>À propos</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">La balise HTML &lt;geolocation> arrive : ce que ça change pour les devs indie</h1><div class=post-meta><span title='2025-01-16 00:00:00 +0000 UTC'>January 16, 2025</span>&nbsp;·&nbsp;<span>4 min</span></div></header><div class=post-content><p>Chrome 144 introduit un nouvel élément HTML : <code>&lt;geolocation></code>. Pour les indie hackers qui développent des apps web avec des fonctionnalités de localisation, c&rsquo;est une simplification bienvenue — et une occasion de réfléchir aux limites du web face au natif.</p><h2 id=ce-que-change-la-balise-geolocation>Ce que change la balise <code>&lt;geolocation></code><a hidden class=anchor aria-hidden=true href=#ce-que-change-la-balise-geolocation>#</a></h2><p>Jusqu&rsquo;à maintenant, demander la position d&rsquo;un utilisateur passait par l&rsquo;API JavaScript <code>navigator.geolocation.getCurrentPosition()</code>. Le problème : cette approche impérative déclenche des popups d&rsquo;autorisation qui interrompent l&rsquo;utilisateur, souvent au mauvais moment. Pire, si l&rsquo;utilisateur refuse trois fois, Chrome bloque silencieusement les demandes pendant une semaine. Ton code échoue sans explication.</p><p>La nouvelle balise <code>&lt;geolocation></code> change la donne. L&rsquo;autorisation est déclenchée uniquement quand l&rsquo;utilisateur clique sur l&rsquo;élément — pas au chargement de la page, pas via un script. C&rsquo;est déclaratif, contextuel, et contrôlé par le navigateur.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>geolocation</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>onlocation</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;handleLocation(event)&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>accuracymode</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;precise&#34;</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>geolocation</span>&gt;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>handleLocation</span>(<span style=color:#a6e22e>event</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>position</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>latitude</span>, <span style=color:#a6e22e>longitude</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>position</span>.<span style=color:#a6e22e>coords</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Position :&#34;</span>, <span style=color:#a6e22e>latitude</span>, <span style=color:#a6e22e>longitude</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Plus besoin de gérer manuellement les callbacks, les états d&rsquo;erreur, les cas de blocage. Le navigateur s&rsquo;occupe de tout, y compris d&rsquo;un flux de récupération si l&rsquo;utilisateur avait précédemment bloqué l&rsquo;accès.</p><h2 id=les-chiffres-qui-valident-le-concept>Les chiffres qui valident le concept<a hidden class=anchor aria-hidden=true href=#les-chiffres-qui-valident-le-concept>#</a></h2><p>Avant de lancer la balise <code>&lt;geolocation></code>, Chrome a testé un élément générique <code>&lt;permission></code> pendant plusieurs versions. Les résultats sont parlants :</p><ul><li><strong>Zoom</strong> : -46,9% d&rsquo;erreurs de capture caméra/micro</li><li><strong>Immobiliare.it</strong> : +20% de flux de géolocalisation réussis</li><li><strong>ZapImóveis</strong> : 54,4% de récupération pour les utilisateurs précédemment bloqués</li></ul><p>Le problème n&rsquo;était pas la fonctionnalité. C&rsquo;était le manque de contexte au moment de la demande.</p><h2 id=le-parallèle-avec-mon-projet-track>Le parallèle avec mon projet Track<a hidden class=anchor aria-hidden=true href=#le-parallèle-avec-mon-projet-track>#</a></h2><p>J&rsquo;ai récemment terminé <a href=https://www.jpinard.ch/projets/tracks>Track</a>, une PWA de tracking sportif développée dans le cadre d&rsquo;un projet croisé entre deux cours à la HEIG-VD (ArchiOWeb et DevMobil). L&rsquo;app enregistre les sorties running/vélo via les capteurs du téléphone : tracé GPS en temps réel, calcul de distance et dénivelé, photos géolocalisées, enrichissement météo automatique.</p><p>La géolocalisation était au cœur du projet. Avec l&rsquo;API JavaScript actuelle, j&rsquo;ai dû gérer pas mal de cas limites : utilisateur qui refuse, blocage silencieux, demande qui arrive trop tôt dans le flow. La balise <code>&lt;geolocation></code> aurait simplifié cette partie du code.</p><p>Mais — et c&rsquo;est là que ça devient intéressant — même avec cette amélioration, le web reste limité face au natif.</p><h2 id=les-limites-du-web--lexemple-de-laltimètre-barométrique>Les limites du web : l&rsquo;exemple de l&rsquo;altimètre barométrique<a hidden class=anchor aria-hidden=true href=#les-limites-du-web--lexemple-de-laltimètre-barométrique>#</a></h2><p>En développant Track, j&rsquo;ai voulu intégrer l&rsquo;altitude barométrique. Sur une app native, l&rsquo;altimètre du téléphone donne une altitude précise et réactive, idéale pour calculer le dénivelé en temps réel.</p><p>Sur le web ? Impossible. L&rsquo;API Geolocation donne une altitude GPS, mais elle est bruitée et peu fiable pour du tracking sportif précis. L&rsquo;altimètre barométrique, lui, n&rsquo;est tout simplement pas exposé aux applications web.</p><p>C&rsquo;est le genre de friction qui pousse certains projets vers le natif ou vers des solutions hybrides comme Capacitor. Pour un side project ou un MVP, ça peut être un deal-breaker.</p><p>La balise <code>&lt;geolocation></code> améliore l&rsquo;expérience utilisateur, mais elle ne résout pas ce problème fondamental : certains capteurs restent hors de portée du web.</p><h2 id=pourquoi-cest-pertinent-pour-les-indie-hackers>Pourquoi c&rsquo;est pertinent pour les indie hackers<a hidden class=anchor aria-hidden=true href=#pourquoi-cest-pertinent-pour-les-indie-hackers>#</a></h2><p>Cette évolution s&rsquo;adresse surtout aux indie hackers avec un background dev — ceux qui comprennent comment fonctionne l&rsquo;API Geolocation actuelle et qui peuvent apprécier la simplification.</p><p>Concrètement, si tu développes :</p><ul><li>Une app de livraison ou de services géolocalisés</li><li>Un outil de tracking (sport, transport, logistique)</li><li>Une fonctionnalité &ldquo;trouver autour de moi&rdquo;</li></ul><p>&mldr;cette balise va te faire gagner du temps et améliorer ton taux de conversion sur les autorisations.</p><p>L&rsquo;amélioration progressive est aussi bien pensée : tu peux utiliser la balise avec un fallback vers l&rsquo;API JavaScript pour les navigateurs non compatibles.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>geolocation</span> <span style=color:#a6e22e>onlocation</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;updateMap()&#34;</span>&gt;
</span></span><span style=display:flex><span>  <span style=color:#75715e>&lt;!-- Fallback pour navigateurs non compatibles --&gt;</span>
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onclick</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;navigator.geolocation.getCurrentPosition(updateMap)&#34;</span>&gt;
</span></span><span style=display:flex><span>    Utiliser ma position
</span></span><span style=display:flex><span>  &lt;/<span style=color:#f92672>button</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>geolocation</span>&gt;
</span></span></code></pre></div><h2 id=quand-cette-info-me-sera-utile>Quand cette info me sera utile<a hidden class=anchor aria-hidden=true href=#quand-cette-info-me-sera-utile>#</a></h2><p>Pour mes futurs projets demandant la géolocalisation, je garderai cette balise en tête. Elle simplifie le code, améliore l&rsquo;UX, et réduit les frictions liées aux permissions.</p><p>Mais je resterai aussi conscient des limites du web. Pour certains cas d&rsquo;usage sportifs ou IoT, le natif reste incontournable. La question à se poser avant de commencer : est-ce que les capteurs dont j&rsquo;ai besoin sont accessibles depuis le navigateur ?</p><p>Source : <a href="https://developer.chrome.com/blog/geolocation-html-element?hl=fr">Chrome for Developers</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://example.org/tags/html/>HTML</a></li><li><a href=https://example.org/tags/g%C3%A9olocalisation/>Géolocalisation</a></li><li><a href=https://example.org/tags/web-api/>Web API</a></li><li><a href=https://example.org/tags/chrome/>Chrome</a></li></ul><nav class=paginav><a class=prev href=https://example.org/articles/article-kleo-62k-mrr/><span class=title>« Prev</span><br><span>De 0 à 62k$ MRR en trois mois : les leçons de Kleo</span>
</a><a class=next href=https://example.org/articles/claude-cowork-security-breach/><span class=title>Next »</span><br><span>Claude Cowork exfiltre des fichiers : ce que ça signifie pour les indie hackers</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://example.org/>LabVeilleTech - Ksel</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>